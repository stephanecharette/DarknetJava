// Generated by jextract

package darknet;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class darknet {

    darknet() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup("libdarknet.so", LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int DARKNET_WEIGHTS_VERSION_MAJOR = (int)0L;
    /**
     * {@snippet lang=c :
     * #define DARKNET_WEIGHTS_VERSION_MAJOR 0
     * }
     */
    public static int DARKNET_WEIGHTS_VERSION_MAJOR() {
        return DARKNET_WEIGHTS_VERSION_MAJOR;
    }
    private static final int DARKNET_WEIGHTS_VERSION_MINOR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define DARKNET_WEIGHTS_VERSION_MINOR 2
     * }
     */
    public static int DARKNET_WEIGHTS_VERSION_MINOR() {
        return DARKNET_WEIGHTS_VERSION_MINOR;
    }
    private static final int DARKNET_WEIGHTS_VERSION_PATCH = (int)5L;
    /**
     * {@snippet lang=c :
     * #define DARKNET_WEIGHTS_VERSION_PATCH 5
     * }
     */
    public static int DARKNET_WEIGHTS_VERSION_PATCH() {
        return DARKNET_WEIGHTS_VERSION_PATCH;
    }
    private static final int DARKNET_WEIGHTS_VERSION_TWEAK = (int)4L;
    /**
     * {@snippet lang=c :
     * #define DARKNET_WEIGHTS_VERSION_TWEAK 4
     * }
     */
    public static int DARKNET_WEIGHTS_VERSION_TWEAK() {
        return DARKNET_WEIGHTS_VERSION_TWEAK;
    }
    private static final int true_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define true 1
     * }
     */
    public static int true_() {
        return true_;
    }
    private static final int false_ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define false 0
     * }
     */
    public static int false_() {
        return false_;
    }
    private static final int __bool_true_false_are_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __bool_true_false_are_defined 1
     * }
     */
    public static int __bool_true_false_are_defined() {
        return __bool_true_false_are_defined;
    }
    /**
     * {@snippet lang=c :
     * typedef void *DarknetNetworkPtr
     * }
     */
    public static final AddressLayout DarknetNetworkPtr = darknet.C_POINTER;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void darknet_show_version_info()
     * }
     */
    public static class darknet_show_version_info {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(        );
        private static final MemorySegment ADDR = darknet.findOrThrow("darknet_show_version_info");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private darknet_show_version_info(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void darknet_show_version_info()
         * }
         */
        public static darknet_show_version_info makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new darknet_show_version_info(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("darknet_show_version_info", x0);
                }
                 spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * const char *darknet_version_string()
     * }
     */
    public static class darknet_version_string {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                darknet.C_POINTER        );
        private static final MemorySegment ADDR = darknet.findOrThrow("darknet_version_string");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private darknet_version_string(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * const char *darknet_version_string()
         * }
         */
        public static darknet_version_string makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new darknet_version_string(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("darknet_version_string", x0);
                }
                return (MemorySegment) spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * const char *darknet_version_short()
     * }
     */
    public static class darknet_version_short {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                darknet.C_POINTER        );
        private static final MemorySegment ADDR = darknet.findOrThrow("darknet_version_short");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private darknet_version_short(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * const char *darknet_version_short()
         * }
         */
        public static darknet_version_short makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new darknet_version_short(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("darknet_version_short", x0);
                }
                return (MemorySegment) spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class darknet_set_verbose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_BOOL
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("darknet_set_verbose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void darknet_set_verbose(const bool flag)
     * }
     */
    public static FunctionDescriptor darknet_set_verbose$descriptor() {
        return darknet_set_verbose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void darknet_set_verbose(const bool flag)
     * }
     */
    public static MethodHandle darknet_set_verbose$handle() {
        return darknet_set_verbose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void darknet_set_verbose(const bool flag)
     * }
     */
    public static MemorySegment darknet_set_verbose$address() {
        return darknet_set_verbose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void darknet_set_verbose(const bool flag)
     * }
     */
    public static void darknet_set_verbose(boolean flag) {
        var mh$ = darknet_set_verbose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("darknet_set_verbose", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class darknet_set_trace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_BOOL
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("darknet_set_trace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void darknet_set_trace(const bool flag)
     * }
     */
    public static FunctionDescriptor darknet_set_trace$descriptor() {
        return darknet_set_trace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void darknet_set_trace(const bool flag)
     * }
     */
    public static MethodHandle darknet_set_trace$handle() {
        return darknet_set_trace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void darknet_set_trace(const bool flag)
     * }
     */
    public static MemorySegment darknet_set_trace$address() {
        return darknet_set_trace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void darknet_set_trace(const bool flag)
     * }
     */
    public static void darknet_set_trace(boolean flag) {
        var mh$ = darknet_set_trace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("darknet_set_trace", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class darknet_set_gpu_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_INT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("darknet_set_gpu_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void darknet_set_gpu_index(int idx)
     * }
     */
    public static FunctionDescriptor darknet_set_gpu_index$descriptor() {
        return darknet_set_gpu_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void darknet_set_gpu_index(int idx)
     * }
     */
    public static MethodHandle darknet_set_gpu_index$handle() {
        return darknet_set_gpu_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void darknet_set_gpu_index(int idx)
     * }
     */
    public static MemorySegment darknet_set_gpu_index$address() {
        return darknet_set_gpu_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void darknet_set_gpu_index(int idx)
     * }
     */
    public static void darknet_set_gpu_index(int idx) {
        var mh$ = darknet_set_gpu_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("darknet_set_gpu_index", idx);
            }
            mh$.invokeExact(idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class darknet_set_detection_threshold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER,
            darknet.C_FLOAT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("darknet_set_detection_threshold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void darknet_set_detection_threshold(DarknetNetworkPtr ptr, float threshold)
     * }
     */
    public static FunctionDescriptor darknet_set_detection_threshold$descriptor() {
        return darknet_set_detection_threshold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void darknet_set_detection_threshold(DarknetNetworkPtr ptr, float threshold)
     * }
     */
    public static MethodHandle darknet_set_detection_threshold$handle() {
        return darknet_set_detection_threshold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void darknet_set_detection_threshold(DarknetNetworkPtr ptr, float threshold)
     * }
     */
    public static MemorySegment darknet_set_detection_threshold$address() {
        return darknet_set_detection_threshold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void darknet_set_detection_threshold(DarknetNetworkPtr ptr, float threshold)
     * }
     */
    public static void darknet_set_detection_threshold(MemorySegment ptr, float threshold) {
        var mh$ = darknet_set_detection_threshold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("darknet_set_detection_threshold", ptr, threshold);
            }
            mh$.invokeExact(ptr, threshold);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class darknet_set_non_maximal_suppression_threshold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER,
            darknet.C_FLOAT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("darknet_set_non_maximal_suppression_threshold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void darknet_set_non_maximal_suppression_threshold(DarknetNetworkPtr ptr, float threshold)
     * }
     */
    public static FunctionDescriptor darknet_set_non_maximal_suppression_threshold$descriptor() {
        return darknet_set_non_maximal_suppression_threshold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void darknet_set_non_maximal_suppression_threshold(DarknetNetworkPtr ptr, float threshold)
     * }
     */
    public static MethodHandle darknet_set_non_maximal_suppression_threshold$handle() {
        return darknet_set_non_maximal_suppression_threshold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void darknet_set_non_maximal_suppression_threshold(DarknetNetworkPtr ptr, float threshold)
     * }
     */
    public static MemorySegment darknet_set_non_maximal_suppression_threshold$address() {
        return darknet_set_non_maximal_suppression_threshold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void darknet_set_non_maximal_suppression_threshold(DarknetNetworkPtr ptr, float threshold)
     * }
     */
    public static void darknet_set_non_maximal_suppression_threshold(MemorySegment ptr, float threshold) {
        var mh$ = darknet_set_non_maximal_suppression_threshold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("darknet_set_non_maximal_suppression_threshold", ptr, threshold);
            }
            mh$.invokeExact(ptr, threshold);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class darknet_fix_out_of_bound_values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER,
            darknet.C_BOOL
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("darknet_fix_out_of_bound_values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void darknet_fix_out_of_bound_values(DarknetNetworkPtr ptr, const bool toggle)
     * }
     */
    public static FunctionDescriptor darknet_fix_out_of_bound_values$descriptor() {
        return darknet_fix_out_of_bound_values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void darknet_fix_out_of_bound_values(DarknetNetworkPtr ptr, const bool toggle)
     * }
     */
    public static MethodHandle darknet_fix_out_of_bound_values$handle() {
        return darknet_fix_out_of_bound_values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void darknet_fix_out_of_bound_values(DarknetNetworkPtr ptr, const bool toggle)
     * }
     */
    public static MemorySegment darknet_fix_out_of_bound_values$address() {
        return darknet_fix_out_of_bound_values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void darknet_fix_out_of_bound_values(DarknetNetworkPtr ptr, const bool toggle)
     * }
     */
    public static void darknet_fix_out_of_bound_values(MemorySegment ptr, boolean toggle) {
        var mh$ = darknet_fix_out_of_bound_values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("darknet_fix_out_of_bound_values", ptr, toggle);
            }
            mh$.invokeExact(ptr, toggle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class darknet_network_dimensions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER,
            darknet.C_POINTER,
            darknet.C_POINTER,
            darknet.C_POINTER
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("darknet_network_dimensions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void darknet_network_dimensions(DarknetNetworkPtr ptr, int *w, int *h, int *c)
     * }
     */
    public static FunctionDescriptor darknet_network_dimensions$descriptor() {
        return darknet_network_dimensions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void darknet_network_dimensions(DarknetNetworkPtr ptr, int *w, int *h, int *c)
     * }
     */
    public static MethodHandle darknet_network_dimensions$handle() {
        return darknet_network_dimensions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void darknet_network_dimensions(DarknetNetworkPtr ptr, int *w, int *h, int *c)
     * }
     */
    public static MemorySegment darknet_network_dimensions$address() {
        return darknet_network_dimensions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void darknet_network_dimensions(DarknetNetworkPtr ptr, int *w, int *h, int *c)
     * }
     */
    public static void darknet_network_dimensions(MemorySegment ptr, MemorySegment w, MemorySegment h, MemorySegment c) {
        var mh$ = darknet_network_dimensions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("darknet_network_dimensions", ptr, w, h, c);
            }
            mh$.invokeExact(ptr, w, h, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class darknet_load_neural_network {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            darknet.C_POINTER,
            darknet.C_POINTER,
            darknet.C_POINTER,
            darknet.C_POINTER
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("darknet_load_neural_network");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DarknetNetworkPtr darknet_load_neural_network(const char *const cfg_filename, const char *const names_filename, const char *const weights_filename)
     * }
     */
    public static FunctionDescriptor darknet_load_neural_network$descriptor() {
        return darknet_load_neural_network.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DarknetNetworkPtr darknet_load_neural_network(const char *const cfg_filename, const char *const names_filename, const char *const weights_filename)
     * }
     */
    public static MethodHandle darknet_load_neural_network$handle() {
        return darknet_load_neural_network.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DarknetNetworkPtr darknet_load_neural_network(const char *const cfg_filename, const char *const names_filename, const char *const weights_filename)
     * }
     */
    public static MemorySegment darknet_load_neural_network$address() {
        return darknet_load_neural_network.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DarknetNetworkPtr darknet_load_neural_network(const char *const cfg_filename, const char *const names_filename, const char *const weights_filename)
     * }
     */
    public static MemorySegment darknet_load_neural_network(MemorySegment cfg_filename, MemorySegment names_filename, MemorySegment weights_filename) {
        var mh$ = darknet_load_neural_network.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("darknet_load_neural_network", cfg_filename, names_filename, weights_filename);
            }
            return (MemorySegment)mh$.invokeExact(cfg_filename, names_filename, weights_filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class darknet_free_neural_network {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("darknet_free_neural_network");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void darknet_free_neural_network(DarknetNetworkPtr *ptr)
     * }
     */
    public static FunctionDescriptor darknet_free_neural_network$descriptor() {
        return darknet_free_neural_network.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void darknet_free_neural_network(DarknetNetworkPtr *ptr)
     * }
     */
    public static MethodHandle darknet_free_neural_network$handle() {
        return darknet_free_neural_network.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void darknet_free_neural_network(DarknetNetworkPtr *ptr)
     * }
     */
    public static MemorySegment darknet_free_neural_network$address() {
        return darknet_free_neural_network.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void darknet_free_neural_network(DarknetNetworkPtr *ptr)
     * }
     */
    public static void darknet_free_neural_network(MemorySegment ptr) {
        var mh$ = darknet_free_neural_network.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("darknet_free_neural_network", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class darknet_clear_skipped_classes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("darknet_clear_skipped_classes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void darknet_clear_skipped_classes(DarknetNetworkPtr ptr)
     * }
     */
    public static FunctionDescriptor darknet_clear_skipped_classes$descriptor() {
        return darknet_clear_skipped_classes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void darknet_clear_skipped_classes(DarknetNetworkPtr ptr)
     * }
     */
    public static MethodHandle darknet_clear_skipped_classes$handle() {
        return darknet_clear_skipped_classes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void darknet_clear_skipped_classes(DarknetNetworkPtr ptr)
     * }
     */
    public static MemorySegment darknet_clear_skipped_classes$address() {
        return darknet_clear_skipped_classes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void darknet_clear_skipped_classes(DarknetNetworkPtr ptr)
     * }
     */
    public static void darknet_clear_skipped_classes(MemorySegment ptr) {
        var mh$ = darknet_clear_skipped_classes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("darknet_clear_skipped_classes", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class darknet_add_skipped_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER,
            darknet.C_INT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("darknet_add_skipped_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void darknet_add_skipped_class(DarknetNetworkPtr ptr, const int class_to_skip)
     * }
     */
    public static FunctionDescriptor darknet_add_skipped_class$descriptor() {
        return darknet_add_skipped_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void darknet_add_skipped_class(DarknetNetworkPtr ptr, const int class_to_skip)
     * }
     */
    public static MethodHandle darknet_add_skipped_class$handle() {
        return darknet_add_skipped_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void darknet_add_skipped_class(DarknetNetworkPtr ptr, const int class_to_skip)
     * }
     */
    public static MemorySegment darknet_add_skipped_class$address() {
        return darknet_add_skipped_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void darknet_add_skipped_class(DarknetNetworkPtr ptr, const int class_to_skip)
     * }
     */
    public static void darknet_add_skipped_class(MemorySegment ptr, int class_to_skip) {
        var mh$ = darknet_add_skipped_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("darknet_add_skipped_class", ptr, class_to_skip);
            }
            mh$.invokeExact(ptr, class_to_skip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class darknet_del_skipped_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER,
            darknet.C_INT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("darknet_del_skipped_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void darknet_del_skipped_class(DarknetNetworkPtr ptr, const int class_to_include)
     * }
     */
    public static FunctionDescriptor darknet_del_skipped_class$descriptor() {
        return darknet_del_skipped_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void darknet_del_skipped_class(DarknetNetworkPtr ptr, const int class_to_include)
     * }
     */
    public static MethodHandle darknet_del_skipped_class$handle() {
        return darknet_del_skipped_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void darknet_del_skipped_class(DarknetNetworkPtr ptr, const int class_to_include)
     * }
     */
    public static MemorySegment darknet_del_skipped_class$address() {
        return darknet_del_skipped_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void darknet_del_skipped_class(DarknetNetworkPtr ptr, const int class_to_include)
     * }
     */
    public static void darknet_del_skipped_class(MemorySegment ptr, int class_to_include) {
        var mh$ = darknet_del_skipped_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("darknet_del_skipped_class", ptr, class_to_include);
            }
            mh$.invokeExact(ptr, class_to_include);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class darknet_set_output_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("darknet_set_output_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void darknet_set_output_stream(const char *const filename)
     * }
     */
    public static FunctionDescriptor darknet_set_output_stream$descriptor() {
        return darknet_set_output_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void darknet_set_output_stream(const char *const filename)
     * }
     */
    public static MethodHandle darknet_set_output_stream$handle() {
        return darknet_set_output_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void darknet_set_output_stream(const char *const filename)
     * }
     */
    public static MemorySegment darknet_set_output_stream$address() {
        return darknet_set_output_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void darknet_set_output_stream(const char *const filename)
     * }
     */
    public static void darknet_set_output_stream(MemorySegment filename) {
        var mh$ = darknet_set_output_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("darknet_set_output_stream", filename);
            }
            mh$.invokeExact(filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int DEFAULT_NMS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DEFAULT_NMS = 0
     * }
     */
    public static int DEFAULT_NMS() {
        return DEFAULT_NMS;
    }
    private static final int GREEDY_NMS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GREEDY_NMS = 1
     * }
     */
    public static int GREEDY_NMS() {
        return GREEDY_NMS;
    }
    private static final int DIOU_NMS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DIOU_NMS = 2
     * }
     */
    public static int DIOU_NMS() {
        return DIOU_NMS;
    }
    private static final int CORNERS_NMS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CORNERS_NMS = 3
     * }
     */
    public static int CORNERS_NMS() {
        return CORNERS_NMS;
    }

    private static class load_network {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            darknet.C_POINTER,
            darknet.C_POINTER,
            darknet.C_POINTER,
            darknet.C_INT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("load_network");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DarknetNetworkPtr load_network(const char *cfg, const char *weights, int clear)
     * }
     */
    public static FunctionDescriptor load_network$descriptor() {
        return load_network.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DarknetNetworkPtr load_network(const char *cfg, const char *weights, int clear)
     * }
     */
    public static MethodHandle load_network$handle() {
        return load_network.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DarknetNetworkPtr load_network(const char *cfg, const char *weights, int clear)
     * }
     */
    public static MemorySegment load_network$address() {
        return load_network.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DarknetNetworkPtr load_network(const char *cfg, const char *weights, int clear)
     * }
     */
    public static MemorySegment load_network(MemorySegment cfg, MemorySegment weights, int clear) {
        var mh$ = load_network.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("load_network", cfg, weights, clear);
            }
            return (MemorySegment)mh$.invokeExact(cfg, weights, clear);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class load_network_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            darknet.C_POINTER,
            darknet.C_POINTER,
            darknet.C_POINTER,
            darknet.C_INT,
            darknet.C_INT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("load_network_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DarknetNetworkPtr load_network_custom(const char *cfg, const char *weights, int clear, int batch)
     * }
     */
    public static FunctionDescriptor load_network_custom$descriptor() {
        return load_network_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DarknetNetworkPtr load_network_custom(const char *cfg, const char *weights, int clear, int batch)
     * }
     */
    public static MethodHandle load_network_custom$handle() {
        return load_network_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DarknetNetworkPtr load_network_custom(const char *cfg, const char *weights, int clear, int batch)
     * }
     */
    public static MemorySegment load_network_custom$address() {
        return load_network_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DarknetNetworkPtr load_network_custom(const char *cfg, const char *weights, int clear, int batch)
     * }
     */
    public static MemorySegment load_network_custom(MemorySegment cfg, MemorySegment weights, int clear, int batch) {
        var mh$ = load_network_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("load_network_custom", cfg, weights, clear, batch);
            }
            return (MemorySegment)mh$.invokeExact(cfg, weights, clear, batch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free_network_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("free_network_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free_network_ptr(DarknetNetworkPtr ptr)
     * }
     */
    public static FunctionDescriptor free_network_ptr$descriptor() {
        return free_network_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free_network_ptr(DarknetNetworkPtr ptr)
     * }
     */
    public static MethodHandle free_network_ptr$handle() {
        return free_network_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free_network_ptr(DarknetNetworkPtr ptr)
     * }
     */
    public static MemorySegment free_network_ptr$address() {
        return free_network_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free_network_ptr(DarknetNetworkPtr ptr)
     * }
     */
    public static void free_network_ptr(MemorySegment ptr) {
        var mh$ = free_network_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free_network_ptr", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calculate_binary_weights {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("calculate_binary_weights");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void calculate_binary_weights(DarknetNetworkPtr ptr)
     * }
     */
    public static FunctionDescriptor calculate_binary_weights$descriptor() {
        return calculate_binary_weights.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void calculate_binary_weights(DarknetNetworkPtr ptr)
     * }
     */
    public static MethodHandle calculate_binary_weights$handle() {
        return calculate_binary_weights.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void calculate_binary_weights(DarknetNetworkPtr ptr)
     * }
     */
    public static MemorySegment calculate_binary_weights$address() {
        return calculate_binary_weights.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void calculate_binary_weights(DarknetNetworkPtr ptr)
     * }
     */
    public static void calculate_binary_weights(MemorySegment ptr) {
        var mh$ = calculate_binary_weights.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calculate_binary_weights", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class network_predict_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            darknet.C_POINTER,
            darknet.C_POINTER,
            darknet.C_POINTER
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("network_predict_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float *network_predict_ptr(DarknetNetworkPtr ptr, float *input)
     * }
     */
    public static FunctionDescriptor network_predict_ptr$descriptor() {
        return network_predict_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float *network_predict_ptr(DarknetNetworkPtr ptr, float *input)
     * }
     */
    public static MethodHandle network_predict_ptr$handle() {
        return network_predict_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float *network_predict_ptr(DarknetNetworkPtr ptr, float *input)
     * }
     */
    public static MemorySegment network_predict_ptr$address() {
        return network_predict_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float *network_predict_ptr(DarknetNetworkPtr ptr, float *input)
     * }
     */
    public static MemorySegment network_predict_ptr(MemorySegment ptr, MemorySegment input) {
        var mh$ = network_predict_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("network_predict_ptr", ptr, input);
            }
            return (MemorySegment)mh$.invokeExact(ptr, input);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class network_predict_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            darknet.C_POINTER,
            darknet.C_POINTER,
            DarknetImage.layout()
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("network_predict_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float *network_predict_image(DarknetNetworkPtr ptr, const DarknetImage im)
     * }
     */
    public static FunctionDescriptor network_predict_image$descriptor() {
        return network_predict_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float *network_predict_image(DarknetNetworkPtr ptr, const DarknetImage im)
     * }
     */
    public static MethodHandle network_predict_image$handle() {
        return network_predict_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float *network_predict_image(DarknetNetworkPtr ptr, const DarknetImage im)
     * }
     */
    public static MemorySegment network_predict_image$address() {
        return network_predict_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float *network_predict_image(DarknetNetworkPtr ptr, const DarknetImage im)
     * }
     */
    public static MemorySegment network_predict_image(MemorySegment ptr, MemorySegment im) {
        var mh$ = network_predict_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("network_predict_image", ptr, im);
            }
            return (MemorySegment)mh$.invokeExact(ptr, im);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_network_boxes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            darknet.C_POINTER,
            darknet.C_POINTER,
            darknet.C_INT,
            darknet.C_INT,
            darknet.C_FLOAT,
            darknet.C_FLOAT,
            darknet.C_POINTER,
            darknet.C_INT,
            darknet.C_POINTER,
            darknet.C_INT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("get_network_boxes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * detection *get_network_boxes(DarknetNetworkPtr ptr, int w, int h, float thresh, float hier, int *map, int relative, int *num, int letter)
     * }
     */
    public static FunctionDescriptor get_network_boxes$descriptor() {
        return get_network_boxes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * detection *get_network_boxes(DarknetNetworkPtr ptr, int w, int h, float thresh, float hier, int *map, int relative, int *num, int letter)
     * }
     */
    public static MethodHandle get_network_boxes$handle() {
        return get_network_boxes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * detection *get_network_boxes(DarknetNetworkPtr ptr, int w, int h, float thresh, float hier, int *map, int relative, int *num, int letter)
     * }
     */
    public static MemorySegment get_network_boxes$address() {
        return get_network_boxes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * detection *get_network_boxes(DarknetNetworkPtr ptr, int w, int h, float thresh, float hier, int *map, int relative, int *num, int letter)
     * }
     */
    public static MemorySegment get_network_boxes(MemorySegment ptr, int w, int h, float thresh, float hier, MemorySegment map, int relative, MemorySegment num, int letter) {
        var mh$ = get_network_boxes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_network_boxes", ptr, w, h, thresh, hier, map, relative, num, letter);
            }
            return (MemorySegment)mh$.invokeExact(ptr, w, h, thresh, hier, map, relative, num, letter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free_detections {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER,
            darknet.C_INT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("free_detections");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free_detections(detection *dets, int n)
     * }
     */
    public static FunctionDescriptor free_detections$descriptor() {
        return free_detections.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free_detections(detection *dets, int n)
     * }
     */
    public static MethodHandle free_detections$handle() {
        return free_detections.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free_detections(detection *dets, int n)
     * }
     */
    public static MemorySegment free_detections$address() {
        return free_detections.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free_detections(detection *dets, int n)
     * }
     */
    public static void free_detections(MemorySegment dets, int n) {
        var mh$ = free_detections.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free_detections", dets, n);
            }
            mh$.invokeExact(dets, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class make_empty_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            DarknetImage.layout(),
            darknet.C_INT,
            darknet.C_INT,
            darknet.C_INT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("make_empty_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DarknetImage make_empty_image(int w, int h, int c)
     * }
     */
    public static FunctionDescriptor make_empty_image$descriptor() {
        return make_empty_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DarknetImage make_empty_image(int w, int h, int c)
     * }
     */
    public static MethodHandle make_empty_image$handle() {
        return make_empty_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DarknetImage make_empty_image(int w, int h, int c)
     * }
     */
    public static MemorySegment make_empty_image$address() {
        return make_empty_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DarknetImage make_empty_image(int w, int h, int c)
     * }
     */
    public static MemorySegment make_empty_image(SegmentAllocator allocator, int w, int h, int c) {
        var mh$ = make_empty_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("make_empty_image", allocator, w, h, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, w, h, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class make_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            DarknetImage.layout(),
            darknet.C_INT,
            darknet.C_INT,
            darknet.C_INT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("make_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DarknetImage make_image(int w, int h, int c)
     * }
     */
    public static FunctionDescriptor make_image$descriptor() {
        return make_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DarknetImage make_image(int w, int h, int c)
     * }
     */
    public static MethodHandle make_image$handle() {
        return make_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DarknetImage make_image(int w, int h, int c)
     * }
     */
    public static MemorySegment make_image$address() {
        return make_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DarknetImage make_image(int w, int h, int c)
     * }
     */
    public static MemorySegment make_image(SegmentAllocator allocator, int w, int h, int c) {
        var mh$ = make_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("make_image", allocator, w, h, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, w, h, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            DarknetImage.layout()
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("free_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free_image(image im)
     * }
     */
    public static FunctionDescriptor free_image$descriptor() {
        return free_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free_image(image im)
     * }
     */
    public static MethodHandle free_image$handle() {
        return free_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free_image(image im)
     * }
     */
    public static MemorySegment free_image$address() {
        return free_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free_image(image im)
     * }
     */
    public static void free_image(MemorySegment im) {
        var mh$ = free_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free_image", im);
            }
            mh$.invokeExact(im);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class do_nms_sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER,
            darknet.C_INT,
            darknet.C_INT,
            darknet.C_FLOAT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("do_nms_sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void do_nms_sort(detection *dets, int total, int classes, float thresh)
     * }
     */
    public static FunctionDescriptor do_nms_sort$descriptor() {
        return do_nms_sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void do_nms_sort(detection *dets, int total, int classes, float thresh)
     * }
     */
    public static MethodHandle do_nms_sort$handle() {
        return do_nms_sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void do_nms_sort(detection *dets, int total, int classes, float thresh)
     * }
     */
    public static MemorySegment do_nms_sort$address() {
        return do_nms_sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void do_nms_sort(detection *dets, int total, int classes, float thresh)
     * }
     */
    public static void do_nms_sort(MemorySegment dets, int total, int classes, float thresh) {
        var mh$ = do_nms_sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("do_nms_sort", dets, total, classes, thresh);
            }
            mh$.invokeExact(dets, total, classes, thresh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class do_nms_obj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER,
            darknet.C_INT,
            darknet.C_INT,
            darknet.C_FLOAT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("do_nms_obj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void do_nms_obj(detection *dets, int total, int classes, float thresh)
     * }
     */
    public static FunctionDescriptor do_nms_obj$descriptor() {
        return do_nms_obj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void do_nms_obj(detection *dets, int total, int classes, float thresh)
     * }
     */
    public static MethodHandle do_nms_obj$handle() {
        return do_nms_obj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void do_nms_obj(detection *dets, int total, int classes, float thresh)
     * }
     */
    public static MemorySegment do_nms_obj$address() {
        return do_nms_obj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void do_nms_obj(detection *dets, int total, int classes, float thresh)
     * }
     */
    public static void do_nms_obj(MemorySegment dets, int total, int classes, float thresh) {
        var mh$ = do_nms_obj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("do_nms_obj", dets, total, classes, thresh);
            }
            mh$.invokeExact(dets, total, classes, thresh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class diounms_sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER,
            darknet.C_INT,
            darknet.C_INT,
            darknet.C_FLOAT,
            darknet.C_INT,
            darknet.C_FLOAT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("diounms_sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void diounms_sort(detection *dets, int total, int classes, float thresh, NMS_KIND nms_kind, float beta1)
     * }
     */
    public static FunctionDescriptor diounms_sort$descriptor() {
        return diounms_sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void diounms_sort(detection *dets, int total, int classes, float thresh, NMS_KIND nms_kind, float beta1)
     * }
     */
    public static MethodHandle diounms_sort$handle() {
        return diounms_sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void diounms_sort(detection *dets, int total, int classes, float thresh, NMS_KIND nms_kind, float beta1)
     * }
     */
    public static MemorySegment diounms_sort$address() {
        return diounms_sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void diounms_sort(detection *dets, int total, int classes, float thresh, NMS_KIND nms_kind, float beta1)
     * }
     */
    public static void diounms_sort(MemorySegment dets, int total, int classes, float thresh, int nms_kind, float beta1) {
        var mh$ = diounms_sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("diounms_sort", dets, total, classes, thresh, nms_kind, beta1);
            }
            mh$.invokeExact(dets, total, classes, thresh, nms_kind, beta1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copy_image_from_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            DarknetImage.layout(),
            darknet.C_POINTER
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("copy_image_from_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void copy_image_from_bytes(DarknetImage im, char *pdata)
     * }
     */
    public static FunctionDescriptor copy_image_from_bytes$descriptor() {
        return copy_image_from_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void copy_image_from_bytes(DarknetImage im, char *pdata)
     * }
     */
    public static MethodHandle copy_image_from_bytes$handle() {
        return copy_image_from_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void copy_image_from_bytes(DarknetImage im, char *pdata)
     * }
     */
    public static MemorySegment copy_image_from_bytes$address() {
        return copy_image_from_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void copy_image_from_bytes(DarknetImage im, char *pdata)
     * }
     */
    public static void copy_image_from_bytes(MemorySegment im, MemorySegment pdata) {
        var mh$ = copy_image_from_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copy_image_from_bytes", im, pdata);
            }
            mh$.invokeExact(im, pdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cuda_set_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_INT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("cuda_set_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cuda_set_device(int n)
     * }
     */
    public static FunctionDescriptor cuda_set_device$descriptor() {
        return cuda_set_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cuda_set_device(int n)
     * }
     */
    public static MethodHandle cuda_set_device$handle() {
        return cuda_set_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cuda_set_device(int n)
     * }
     */
    public static MemorySegment cuda_set_device$address() {
        return cuda_set_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cuda_set_device(int n)
     * }
     */
    public static void cuda_set_device(int n) {
        var mh$ = cuda_set_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cuda_set_device", n);
            }
            mh$.invokeExact(n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class make_network_boxes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            darknet.C_POINTER,
            darknet.C_POINTER,
            darknet.C_FLOAT,
            darknet.C_POINTER
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("make_network_boxes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * detection *make_network_boxes(DarknetNetworkPtr ptr, float thresh, int *num)
     * }
     */
    public static FunctionDescriptor make_network_boxes$descriptor() {
        return make_network_boxes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * detection *make_network_boxes(DarknetNetworkPtr ptr, float thresh, int *num)
     * }
     */
    public static MethodHandle make_network_boxes$handle() {
        return make_network_boxes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * detection *make_network_boxes(DarknetNetworkPtr ptr, float thresh, int *num)
     * }
     */
    public static MemorySegment make_network_boxes$address() {
        return make_network_boxes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * detection *make_network_boxes(DarknetNetworkPtr ptr, float thresh, int *num)
     * }
     */
    public static MemorySegment make_network_boxes(MemorySegment ptr, float thresh, MemorySegment num) {
        var mh$ = make_network_boxes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("make_network_boxes", ptr, thresh, num);
            }
            return (MemorySegment)mh$.invokeExact(ptr, thresh, num);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free_ptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER,
            darknet.C_INT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("free_ptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free_ptrs(void **ptrs, int n)
     * }
     */
    public static FunctionDescriptor free_ptrs$descriptor() {
        return free_ptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free_ptrs(void **ptrs, int n)
     * }
     */
    public static MethodHandle free_ptrs$handle() {
        return free_ptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free_ptrs(void **ptrs, int n)
     * }
     */
    public static MemorySegment free_ptrs$address() {
        return free_ptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free_ptrs(void **ptrs, int n)
     * }
     */
    public static void free_ptrs(MemorySegment ptrs, int n) {
        var mh$ = free_ptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free_ptrs", ptrs, n);
            }
            mh$.invokeExact(ptrs, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reset_rnn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            darknet.C_POINTER
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("reset_rnn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void reset_rnn(DarknetNetworkPtr ptr)
     * }
     */
    public static FunctionDescriptor reset_rnn$descriptor() {
        return reset_rnn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void reset_rnn(DarknetNetworkPtr ptr)
     * }
     */
    public static MethodHandle reset_rnn$handle() {
        return reset_rnn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void reset_rnn(DarknetNetworkPtr ptr)
     * }
     */
    public static MemorySegment reset_rnn$address() {
        return reset_rnn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void reset_rnn(DarknetNetworkPtr ptr)
     * }
     */
    public static void reset_rnn(MemorySegment ptr) {
        var mh$ = reset_rnn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reset_rnn", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class load_image_v2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            DarknetImage.layout(),
            darknet.C_POINTER,
            darknet.C_INT,
            darknet.C_INT,
            darknet.C_INT
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("load_image_v2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DarknetImage load_image_v2(const char *filename, int desired_width, int desired_height, int channels)
     * }
     */
    public static FunctionDescriptor load_image_v2$descriptor() {
        return load_image_v2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DarknetImage load_image_v2(const char *filename, int desired_width, int desired_height, int channels)
     * }
     */
    public static MethodHandle load_image_v2$handle() {
        return load_image_v2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DarknetImage load_image_v2(const char *filename, int desired_width, int desired_height, int channels)
     * }
     */
    public static MemorySegment load_image_v2$address() {
        return load_image_v2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DarknetImage load_image_v2(const char *filename, int desired_width, int desired_height, int channels)
     * }
     */
    public static MemorySegment load_image_v2(SegmentAllocator allocator, MemorySegment filename, int desired_width, int desired_height, int channels) {
        var mh$ = load_image_v2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("load_image_v2", allocator, filename, desired_width, desired_height, channels);
            }
            return (MemorySegment)mh$.invokeExact(allocator, filename, desired_width, desired_height, channels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class network_predict_image_letterbox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            darknet.C_POINTER,
            darknet.C_POINTER,
            DarknetImage.layout()
        );

        public static final MemorySegment ADDR = darknet.findOrThrow("network_predict_image_letterbox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float *network_predict_image_letterbox(DarknetNetworkPtr ptr, DarknetImage im)
     * }
     */
    public static FunctionDescriptor network_predict_image_letterbox$descriptor() {
        return network_predict_image_letterbox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float *network_predict_image_letterbox(DarknetNetworkPtr ptr, DarknetImage im)
     * }
     */
    public static MethodHandle network_predict_image_letterbox$handle() {
        return network_predict_image_letterbox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float *network_predict_image_letterbox(DarknetNetworkPtr ptr, DarknetImage im)
     * }
     */
    public static MemorySegment network_predict_image_letterbox$address() {
        return network_predict_image_letterbox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float *network_predict_image_letterbox(DarknetNetworkPtr ptr, DarknetImage im)
     * }
     */
    public static MemorySegment network_predict_image_letterbox(MemorySegment ptr, MemorySegment im) {
        var mh$ = network_predict_image_letterbox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("network_predict_image_letterbox", ptr, im);
            }
            return (MemorySegment)mh$.invokeExact(ptr, im);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * #define DARKNET_VERSION_STRING "v5.0-6-geb8e4b3f"
     * }
     */
    public static MemorySegment DARKNET_VERSION_STRING() {
        class Holder {
            static final MemorySegment DARKNET_VERSION_STRING
                = darknet.LIBRARY_ARENA.allocateFrom("v5.0-6-geb8e4b3f");
        }
        return Holder.DARKNET_VERSION_STRING;
    }
    /**
     * {@snippet lang=c :
     * #define DARKNET_VERSION_SHORT "5.0.6"
     * }
     */
    public static MemorySegment DARKNET_VERSION_SHORT() {
        class Holder {
            static final MemorySegment DARKNET_VERSION_SHORT
                = darknet.LIBRARY_ARENA.allocateFrom("5.0.6");
        }
        return Holder.DARKNET_VERSION_SHORT;
    }
    /**
     * {@snippet lang=c :
     * #define DARKNET_VERSION_KEYWORD "Moonlit"
     * }
     */
    public static MemorySegment DARKNET_VERSION_KEYWORD() {
        class Holder {
            static final MemorySegment DARKNET_VERSION_KEYWORD
                = darknet.LIBRARY_ARENA.allocateFrom("Moonlit");
        }
        return Holder.DARKNET_VERSION_KEYWORD;
    }
    /**
     * {@snippet lang=c :
     * #define DARKNET_BRANCH_NAME "v5"
     * }
     */
    public static MemorySegment DARKNET_BRANCH_NAME() {
        class Holder {
            static final MemorySegment DARKNET_BRANCH_NAME
                = darknet.LIBRARY_ARENA.allocateFrom("v5");
        }
        return Holder.DARKNET_BRANCH_NAME;
    }
}

